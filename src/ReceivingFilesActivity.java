/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Madhusudan
 */

import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.Robot;
import java.net.*;
import java.io.*;
import javax.swing.JFileChooser;

public class ReceivingFilesActivity extends javax.swing.JFrame {

    // NUMBER OF FILES TO BE RECEIVED
    public int numberOfFiles = 0;
    public String directory = "";
    /**
     * Creates new form ReceivingFilesActivity
     */
    public ReceivingFilesActivity() {
        initComponents();
        
        jFileChooser1.setDialogTitle("Choose directory to save files");
        jFileChooser1.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        jFileChooser1.setAcceptAllFileFilterUsed(false);
        int action = jFileChooser1.showOpenDialog(null);
        if(action == JFileChooser.APPROVE_OPTION)
        {
            directory = jFileChooser1.getSelectedFile().getPath();
            directory.replaceAll("/", "\\");
            System.out.print("\n"+directory+"\n");
        }
        
        // GETTING NUMBER OF FILES INFORMATION AND THEN START RECEIVING FILES
        GettingInformation gettingInformation = new GettingInformation(this);
        gettingInformation.start();
        
        // KEEPING MACHINE AWAKE
        KeepSendingAwake keepAwake = new KeepSendingAwake();
        keepAwake.start();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jProgressBar1 = new javax.swing.JProgressBar();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Bridge - Receiving Files");
        setResizable(false);

        jLabel1.setText("Receiving File: ");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 302, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(350, Short.MAX_VALUE))
        );

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) throws Exception{
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(ReceivingFilesActivity.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(ReceivingFilesActivity.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(ReceivingFilesActivity.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ReceivingFilesActivity.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ReceivingFilesActivity().setVisible(true);
            }
        });
    }
    
    public void updataGUI(String fileName)
    {
        jLabel2.setText(fileName);
    }
    public void updataGUI(long fileSize, long receivedSize)
    {
        int val = (int) (100-(((float)(fileSize-receivedSize)/(float)fileSize)*100));
        jProgressBar1.setValue(val);
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JProgressBar jProgressBar1;
    // End of variables declaration//GEN-END:variables
}

class GettingInformation extends Thread {
    ReceivingFilesActivity activity;
    GettingInformation(ReceivingFilesActivity param)
    {
        this.activity = param;
    }
    public void run()
    {
        try {
            DatagramSocket socket = new DatagramSocket(9876);
            byte[] temp = new byte[1024];
            DatagramPacket packet = new DatagramPacket(temp, temp.length);
            socket.receive(packet);
            socket.close();
            byte[] messageByte = new byte[packet.getLength()];
            System.arraycopy(packet.getData(), packet.getOffset(), messageByte, 0, packet.getLength());
            String[] message = (new String(messageByte)).split("@");
            System.out.print("\n"+ChooseConnectionActivity.SelectedIp+" chck "+message[1]);
            if(message[1].trim().equals(ChooseConnectionActivity.SelectedIp))
            {
                this.activity.numberOfFiles = Integer.parseInt(message[0]);
                System.out.print("\nreceived data\nNumber of files: "+this.activity.numberOfFiles);
                Thread.sleep(1000);
                
                // SENDING RECEIVED RESPONSE
                DatagramSocket responseSocket = new DatagramSocket();
                String myIp = InetAddress.getLocalHost().getHostAddress();
                DatagramPacket responsePacket = new DatagramPacket(myIp.getBytes(), myIp.getBytes().length, InetAddress.getByName(ChooseConnectionActivity.SelectedIp), 9876);
                responseSocket.send(responsePacket);
                System.out.print("\nsent response");

                // START RECEIVING FILES
                ReceivingFiles receiving = new ReceivingFiles(activity);
                receiving.start();
            }
            else {
                GettingInformation gettingInformation = new GettingInformation(activity);
                gettingInformation.start();
            }
        } catch (Exception e) { }
    }
}

class ReceivingFiles extends Thread {
    ReceivingFilesActivity activity;
    ReceivingFiles(ReceivingFilesActivity param){
        this.activity = param;
    }
    public void run()
    {
        for(int k = 0; k < this.activity.numberOfFiles; k++) {
            try {
                // RECEIVING FILE DETAILS TO SAVE
                DatagramSocket tempSocket = new DatagramSocket(6397);
                byte[] temp = new byte[1024];
                DatagramPacket tempPacket = new DatagramPacket(temp, temp.length);
                tempSocket.receive(tempPacket);
                tempSocket.close();
                byte[] tempByte = new byte[tempPacket.getLength()];
                System.arraycopy(tempPacket.getData(), tempPacket.getOffset(), tempByte, 0, tempPacket.getLength());
                String[] message = (new String(tempByte)).split("@");
                String fileName = message[0].trim();
                long fileSize = Long.valueOf(message[1].trim()).longValue();
                System.out.print("\n\n"+fileName+"\n"+fileSize);
                this.activity.updataGUI(fileName);
                Thread.sleep(1000);
                
                
                Socket socket = new Socket(InetAddress.getByName(ChooseConnectionActivity.SelectedIp), 1997);
                byte[] byteArray = new byte[100000000];
                InputStream in = new BufferedInputStream(socket.getInputStream()); //socket.getInputStream();
                String path = this.activity.directory + "\\" + fileName;
                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(path));
                System.out.print("\n"+path);
                int bytesRead;
                long receivedData = 0;
                while((bytesRead = in.read(byteArray, 0, byteArray.length)) != -1)
                {
                    bos.write(byteArray, 0, bytesRead);
                    receivedData += bytesRead;
                    this.activity.updataGUI(fileSize, receivedData);
                }
                System.out.print("\nReceived");
                bos.flush();
                bos.close();
                socket.close();
                Thread.sleep(500);
            } catch(Exception e) { e.printStackTrace(); }
        }
        
        // RECEIVED ALL FILES, GOING TO MAINACTIVITY
        MainActivity main = new MainActivity();
        main.show();
    }
}

class KeepReceivingAwake extends Thread {
    public void run()
    {
        try {
            Robot hal = new Robot();
            while(true) {
                hal.delay(1000 * 60);
                Point pointer = MouseInfo.getPointerInfo().getLocation();
                hal.mouseMove(pointer.x+1, pointer.y+1);
                hal.mouseMove(pointer.x-1, pointer.y-1);
                pointer = MouseInfo.getPointerInfo().getLocation();
            }
        } catch(Exception e) { }
    }
}